#!/bin/bash

# Enhanced Flutter Controller with logging and monitoring for Claude
# Provides comprehensive control and logging for Flutter development

# Create log directory if it doesn't exist
LOG_DIR="/tmp/flutter_controller"
SCREENSHOT_DIR="$LOG_DIR/screenshots"
mkdir -p "$LOG_DIR" "$SCREENSHOT_DIR"

PIPE="$LOG_DIR/flutter_cmd"
LOG_FILE="$LOG_DIR/flutter_output.log"
PID_FILE="$LOG_DIR/flutter.pid"
STATUS_FILE="$LOG_DIR/flutter_status"
WORKDIR_FILE="$LOG_DIR/flutter_workdir"
MAX_LOG_SIZE=10485760  # 10MB
READINESS_TIMEOUT=30   # seconds
PIPE_CHECK_TIMEOUT=5   # seconds

# Utility functions
log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

update_status() {
    echo "$1|$(date '+%Y-%m-%d %H:%M:%S')" > "$STATUS_FILE"
}

# Screenshot functionality
take_screenshot() {
    local device=${1:-"emulator-5554"}
    local timestamp=$(date '+%Y%m%d_%H%M%S')
    local screenshot_path="$SCREENSHOT_DIR/screenshot_${timestamp}.png"
    local latest_screenshot="/tmp/screenshot.png"
    
    log_message "Taking screenshot from $device"
    
    # Take screenshot using adb
    if adb -s "$device" shell screencap -p > "$screenshot_path" 2>/dev/null; then
        # Copy to /tmp for easy access
        cp "$screenshot_path" "$latest_screenshot"
        log_message "Screenshot saved: $screenshot_path"
        echo "Screenshot saved to: $screenshot_path"
        echo "Latest screenshot: $latest_screenshot"
        return 0
    else
        log_message "ERROR: Failed to take screenshot from $device"
        echo "ERROR: Failed to take screenshot. Is the device connected?"
        return 1
    fi
}

# Check if pipe is responsive
check_pipe_responsiveness() {
    if [[ ! -p "$PIPE" ]]; then
        return 1
    fi
    
    # Try to write to pipe with timeout
    if timeout "$PIPE_CHECK_TIMEOUT" bash -c "echo 'h' > '$PIPE'" 2>/dev/null; then
        return 0
    else
        return 1
    fi
}

# Wait for Flutter to be ready to accept commands
wait_for_flutter_ready() {
    local timeout=${1:-$READINESS_TIMEOUT}
    local start_time=$(date +%s)
    
    echo "Waiting for Flutter to be ready (timeout: ${timeout}s)..."
    
    while [[ $(($(date +%s) - start_time)) -lt $timeout ]]; do
        # First check if pipe is responsive - this is the most reliable indicator
        if check_pipe_responsiveness; then
            # Additionally check status file for running state
            local current_status=""
            if [[ -f "$STATUS_FILE" ]]; then
                IFS='|' read -r current_status _ < "$STATUS_FILE"
            fi
            
            case "$current_status" in
                "RUNNING"|"HOT_RELOAD"|"HOT_RESTART"|"HOT_RELOAD_REQUESTED"|"HOT_RESTART_REQUESTED")
                    echo "✓ Flutter is ready to accept commands"
                    return 0
                    ;;
            esac
        fi
        
        # Also check for readiness markers in recent logs
        if [[ -f "$LOG_FILE" ]] && tail -n 50 "$LOG_FILE" | grep -q "Flutter run key commands"; then
            if check_pipe_responsiveness; then
                echo "✓ Flutter is ready to accept commands"
                return 0
            fi
        fi
        
        echo -n "."
        sleep 1
    done
    
    echo ""
    echo "⚠ Timeout waiting for Flutter to be ready"
    return 1
}

# Enhanced health check
flutter_health_check() {
    local pid_check=false
    local pipe_check=false
    local ready_check=false
    
    # Check PID
    if [[ -f "$PID_FILE" ]]; then
        local pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            pid_check=true
        fi
    fi
    
    # Check pipe responsiveness
    if check_pipe_responsiveness; then
        pipe_check=true
    fi
    
    # Check for ready state in logs
    if [[ -f "$LOG_FILE" ]] && tail -n 20 "$LOG_FILE" | grep -q "Flutter run key commands"; then
        ready_check=true
    fi
    
    echo "Health Check Results:"
    echo "  PID alive: $([ "$pid_check" = true ] && echo "✓" || echo "✗")"
    echo "  Pipe responsive: $([ "$pipe_check" = true ] && echo "✓" || echo "✗")"
    echo "  Flutter ready: $([ "$ready_check" = true ] && echo "✓" || echo "✗")"
    
    # Return 0 only if all checks pass
    [ "$pid_check" = true ] && [ "$pipe_check" = true ] && [ "$ready_check" = true ]
}

# Clean stale state files when detecting issues
clean_stale_state() {
    local reason="$1"
    log_message "Cleaning stale state files: $reason"
    
    # Remove stale PID file if process doesn't exist
    if [[ -f "$PID_FILE" ]]; then
        local pid=$(cat "$PID_FILE")
        if ! kill -0 "$pid" 2>/dev/null; then
            rm -f "$PID_FILE"
            log_message "Removed stale PID file"
        fi
    fi
    
    # Update status to reflect reality
    if [[ -f "$STATUS_FILE" ]]; then
        local current_status
        IFS='|' read -r current_status _ < "$STATUS_FILE"
        if [[ "$current_status" == "RUNNING" ]]; then
            update_status "CRASHED"
        fi
    fi
}

rotate_logs() {
    if [[ -f "$LOG_FILE" ]] && [[ -s "$LOG_FILE" ]]; then
        # Create archive subdirectory if it doesn't exist
        mkdir -p "$LOG_DIR/archive"
        
        # Create timestamped archive filename
        local timestamp=$(date '+%Y%m%d_%H%M%S')
        local archive_file="$LOG_DIR/archive/flutter_output_${timestamp}.log"
        
        log_message "Rotating logs to: $archive_file"
        
        # Copy current log to archive
        cp "$LOG_FILE" "$archive_file"
        
        # Truncate the main log file
        > "$LOG_FILE"
        
        log_message "Log rotation completed - archived and truncated"
    fi
}

setup_flutter_pipe() {
    local device=${1:-"emulator-5554"}
    
    # Clean up any existing setup
    cleanup_flutter_process
    rotate_logs
    
    # Create pipe if needed
    [[ -e "$PIPE" && ! -p "$PIPE" ]] && rm "$PIPE"
    [[ ! -p "$PIPE" ]] && mkfifo "$PIPE"
    
    # Change to Flutter app directory
    cd ./free_flight_log_app || {
        log_message "ERROR: Cannot change to Flutter app directory"
        update_status "ERROR"
        return 1
    }
    
    # Save the working directory for status display
    echo "$PWD" > "$WORKDIR_FILE"
    
    log_message "Starting Flutter on $device in $PWD"
    update_status "STARTING"
    
    # Start Flutter with comprehensive logging
    {
        tail -f "$PIPE" | flutter run -d "$device" 2>&1 | while IFS= read -r line; do
            echo "$line" | tee -a "$LOG_FILE"
            
            # Monitor for specific events
            case "$line" in
                *"Flutter run key commands"*)
                    update_status "RUNNING"
                    ;;
                *"Application finished"*)
                    update_status "STOPPED"
                    ;;
                *"EXCEPTION CAUGHT"*|*"ERROR"*|*"FATAL"*)
                    update_status "ERROR"
                    ;;
                *"Hot reload"*)
                    update_status "HOT_RELOAD"
                    ;;
                *"Hot restart"*)
                    update_status "HOT_RESTART"
                    ;;
            esac
        done
    } &
    
    # Store the background process PID
    echo $! > "$PID_FILE"
    log_message "Flutter controller started with PID: $!"
}

cleanup_flutter_process() {
    if [[ -f "$PID_FILE" ]]; then
        local pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            log_message "Cleaning up Flutter process (PID: $pid)"
            kill "$pid" 2>/dev/null
            sleep 2
            kill -9 "$pid" 2>/dev/null
        fi
        rm -f "$PID_FILE"
    fi
    
    # Clean up any remaining Flutter processes
    pkill -f "flutter run" 2>/dev/null
    pkill -f "tail -f $LOG_DIR/flutter_cmd" 2>/dev/null
    
    update_status "STOPPED"
}

check_flutter_status() {
    local status="UNKNOWN"
    local timestamp=""
    
    if [[ -f "$STATUS_FILE" ]]; then
        IFS='|' read -r status timestamp < "$STATUS_FILE"
    fi
    
    # Enhanced state verification
    local pid_exists=false
    local pipe_responsive=false
    
    # Check PID
    if [[ -f "$PID_FILE" ]]; then
        local pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            pid_exists=true
        else
            clean_stale_state "Dead process detected"
            status="CRASHED"
            update_status "CRASHED"
        fi
    else
        if [[ "$status" == "RUNNING" ]]; then
            clean_stale_state "Missing PID file"
            status="STOPPED"
            update_status "STOPPED"
        fi
    fi
    
    # Check pipe responsiveness if PID exists
    if [[ "$pid_exists" == true ]]; then
        if check_pipe_responsiveness; then
            pipe_responsive=true
        else
            # PID exists but pipe unresponsive - potential issue
            if [[ "$status" == "RUNNING" ]]; then
                log_message "WARNING: Process alive but pipe unresponsive"
                status="UNRESPONSIVE"
                update_status "UNRESPONSIVE"
            fi
        fi
    fi
    
    echo "Flutter Status: $status"
    if [[ -n "$timestamp" ]]; then
        echo "Last Update: $timestamp"
    fi
    
    # Show working directory if available
    if [[ -f "$WORKDIR_FILE" ]]; then
        local workdir=$(cat "$WORKDIR_FILE")
        echo "Working Directory: $workdir"
    fi
    
    # Show process and pipe status
    echo "Process Status: $([ "$pid_exists" = true ] && echo "✓ Running" || echo "✗ Not running")"
    echo "Pipe Status: $([ "$pipe_responsive" = true ] && echo "✓ Responsive" || echo "✗ Unresponsive")"
    
    # Show recent activity from logs
    if [[ -f "$LOG_FILE" ]]; then
        echo "Recent Activity:"
        tail -n 3 "$LOG_FILE" 2>/dev/null | sed 's/^/  /'
    fi
    
    case "$status" in
        "RUNNING") 
            # Additional validation for RUNNING status
            if [[ "$pid_exists" == true ]] && [[ "$pipe_responsive" == true ]]; then
                return 0
            else
                return 1
            fi
            ;;
        "STARTING") return 0 ;;
        "HOT_RELOAD") return 0 ;;
        "HOT_RESTART") return 0 ;;
        "HOT_RELOAD_REQUESTED") return 0 ;;
        "HOT_RESTART_REQUESTED") return 0 ;;
        *) return 1 ;;
    esac
}

# Pre-command check to ensure Flutter is in the right state
pre_command_check() {
    local cmd="$1"
    local auto_start=${2:-false}

    # Get current status
    local status="UNKNOWN"
    local pid_exists=false
    local pipe_responsive=false

    if [[ -f "$STATUS_FILE" ]]; then
        IFS='|' read -r status _ < "$STATUS_FILE"
    fi

    # Check if PID exists and is alive
    if [[ -f "$PID_FILE" ]]; then
        local pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            pid_exists=true
        else
            log_message "Detected dead process (PID: $pid), cleaning up..."
            clean_stale_state "Dead process detected"
            status="STOPPED"
        fi
    fi

    # Check pipe responsiveness
    if [[ -p "$PIPE" ]]; then
        if check_pipe_responsiveness; then
            pipe_responsive=true
        fi
    fi

    # Decision logic based on command and status
    case "$status" in
        "RUNNING"|"HOT_RELOAD"|"HOT_RESTART"|"HOT_RELOAD_REQUESTED"|"HOT_RESTART_REQUESTED")
            if [[ "$pid_exists" == true ]] && [[ "$pipe_responsive" == true ]]; then
                log_message "Flutter is ready for command: $cmd"
                return 0
            elif [[ "$pid_exists" == true ]] && [[ "$pipe_responsive" == false ]]; then
                echo "⚠ Flutter process is running but unresponsive"
                echo "Try: flutter_controller_enhanced cleanup && flutter_controller_enhanced run"
                return 1
            else
                echo "⚠ Flutter status shows running but process is dead"
                clean_stale_state "Inconsistent state"
                if [[ "$auto_start" == true ]] && [[ "$cmd" =~ ^[rR]$ ]]; then
                    echo "Auto-starting Flutter..."
                    setup_flutter_pipe "emulator-5554"
                    if wait_for_flutter_ready 30; then
                        return 0
                    fi
                fi
                return 1
            fi
            ;;
        "STARTING")
            echo "Flutter is starting up, waiting for readiness..."
            if wait_for_flutter_ready 30; then
                return 0
            else
                echo "⚠ Flutter failed to become ready"
                return 1
            fi
            ;;
        "STOPPED"|"CRASHED"|"ERROR")
            if [[ "$auto_start" == true ]] && [[ "$cmd" =~ ^[rR]$ ]]; then
                echo "Flutter is not running. Auto-starting..."
                cleanup_flutter_process  # Clean up any remnants
                setup_flutter_pipe "emulator-5554"
                if wait_for_flutter_ready 30; then
                    return 0
                else
                    echo "⚠ Failed to auto-start Flutter"
                    return 1
                fi
            else
                echo "ERROR: Flutter is not running (status: $status)"
                echo "Run: flutter_controller_enhanced run"
                return 1
            fi
            ;;
        "UNRESPONSIVE")
            echo "⚠ Flutter is unresponsive. Attempting recovery..."
            cleanup_flutter_process
            if [[ "$auto_start" == true ]]; then
                setup_flutter_pipe "emulator-5554"
                if wait_for_flutter_ready 30; then
                    return 0
                fi
            fi
            echo "Recovery failed. Please run: flutter_controller_enhanced cleanup && flutter_controller_enhanced run"
            return 1
            ;;
        *)
            echo "⚠ Unknown Flutter status: $status"
            if [[ "$auto_start" == true ]] && [[ "$cmd" =~ ^[rR]$ ]]; then
                echo "Attempting to start Flutter..."
                cleanup_flutter_process
                setup_flutter_pipe "emulator-5554"
                if wait_for_flutter_ready 30; then
                    return 0
                fi
            fi
            return 1
            ;;
    esac
}

send_flutter_command() {
    local cmd="$1"
    local validate_ready=${2:-true}
    local auto_start=${3:-false}

    # Pre-command validation
    if [[ "$validate_ready" == true ]]; then
        if ! pre_command_check "$cmd" "$auto_start"; then
            return 1
        fi
    fi

    # Ensure pipe exists after pre-command check
    if [[ ! -p "$PIPE" ]]; then
        echo "ERROR: Flutter pipe not found after validation"
        return 1
    fi

    log_message "Sending command: $cmd"

    # Send command with error handling
    if ! echo "$cmd" > "$PIPE" 2>/dev/null; then
        log_message "ERROR: Failed to send command to pipe"
        echo "ERROR: Failed to send command. Pipe may be broken."
        return 1
    fi

    case "$cmd" in
        "r") update_status "HOT_RELOAD_REQUESTED" ;;
        "R") update_status "HOT_RESTART_REQUESTED" ;;
        "q")
            update_status "QUIT_REQUESTED"
            sleep 3
            cleanup_flutter_process
            ;;
    esac

    return 0
}

show_logs() {
    local lines=${1:-50}
    if [[ -f "$LOG_FILE" ]]; then
        tail -n "$lines" "$LOG_FILE"
    else
        echo "No log file found at $LOG_FILE"
    fi
}

clear_logs() {
    > "$LOG_FILE"
    log_message "Log file cleared by user request"
}

monitor_logs() {
    echo "Monitoring Flutter logs (Ctrl+C to exit)..."
    if [[ -f "$LOG_FILE" ]]; then
        tail -f "$LOG_FILE"
    else
        echo "No log file found. Start Flutter first."
        return 1
    fi
}

restart_flutter() {
    local device=${1:-"emulator-5554"}
    log_message "Restarting Flutter..."
    cleanup_flutter_process
    sleep 2
    setup_flutter_pipe "$device"
}

# Main command handling
case "$1" in
    "run")
        # Check if already running and cleanup if needed
        if check_flutter_status >/dev/null 2>&1; then
            log_message "WARNING: Flutter is already running. Cleaning up and restarting..."
            cleanup_flutter_process
            sleep 2
        fi
        setup_flutter_pipe "$2"
        ;;
    "r")
        # Hot reload with auto-start if needed
        send_flutter_command "r" true true
        ;;
    "R")
        # Hot restart with auto-start if needed
        send_flutter_command "R" true true
        ;;
    "q"|"quit")
        send_flutter_command "q"
        ;;
    "status")
        check_flutter_status
        ;;
    "logs")
        show_logs "$2"
        ;;
    "clear-logs")
        clear_logs
        ;;
    "monitor")
        monitor_logs
        ;;
    "restart")
        restart_flutter "$2"
        ;;
    "cleanup")
        cleanup_flutter_process
        ;;
    "screenshot"|"ss")
        take_screenshot "$2"
        ;;
    "health")
        flutter_health_check
        ;;
    "wait-ready")
        wait_for_flutter_ready "$2"
        ;;
    *)
        echo "Enhanced Flutter Controller v2.2"
        echo "Usage: $0 {command} [options]"
        echo ""
        echo "Commands:"
        echo "  run [device]     - Start Flutter with logging (default: emulator-5554)"
        echo "  r                - Hot reload (with readiness check)"
        echo "  R                - Hot restart (with readiness check)"
        echo "  q, quit          - Quit Flutter"
        echo "  status           - Check Flutter status and health"
        echo "  logs [lines]     - Show recent logs (default: 50 lines)"
        echo "  clear-logs       - Clear the log file"
        echo "  monitor          - Monitor logs in real-time"
        echo "  restart [device] - Force restart Flutter"
        echo "  cleanup          - Clean up crashed processes"
        echo ""
        echo "Enhanced Commands:"
        echo "  screenshot, ss [device] - Take screenshot via adb (default: emulator-5554)"
        echo "  health           - Comprehensive health check (PID, pipe, readiness)"
        echo "  wait-ready [timeout] - Wait for Flutter to be ready (default: 30s)"
        echo ""
        echo "Log Files:"
        echo "  Directory: $LOG_DIR"
        echo "  Output:    $LOG_FILE"
        echo "  Status:    $STATUS_FILE" 
        echo "  PID:       $PID_FILE"
        echo ""
        echo "Examples:"
        echo "  $0 run                    # Start Flutter on default emulator"
        echo "  $0 run chrome             # Start Flutter on Chrome"
        echo "  $0 status                 # Check if Flutter is running"
        echo "  $0 health                 # Comprehensive health check"
        echo "  $0 logs 100               # Show last 100 log lines"
        echo "  $0 monitor                # Watch logs in real-time"
        echo "  $0 screenshot             # Take screenshot from emulator"
        echo "  $0 ss emulator-5556       # Take screenshot from specific device"
        ;;
esac
